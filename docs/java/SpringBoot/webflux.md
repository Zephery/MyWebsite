# Webflux
### 1.Servlet 3.1就已经支持异步非阻塞，为什么要用webflux?
ChatGpt:
Servlet 3.1 和 WebFlux 虽然底层都使用了 Java 的 NIO（非阻塞 IO），但是他们的编程模型和如何使用 NIO 是不同的，这也是导致他们性能差异的原因。

Servlet 3.1：虽然 Servlet 3.1 支持非阻塞 IO，但是它的 API 设计仍然是基于传统的阻塞模型，这意味着每个请求通常会在一个单独的线程中处理，直到请求处理完成并返回响应。这种模型在并发请求数量较少的情况下工作得很好，但是在高并发的情况下，可能会因为线程数量过多而导致资源消耗过大，性能下降。

WebFlux：WebFlux 是基于反应式编程模型的，它使用少量的线程（通常与 CPU 核心数相同）和事件驱动的方式来处理大量的并发请求。这种模型可以更有效地利用系统资源，特别是在高并发的情况下。此外，WebFlux 还支持 backpressure（背压），可以更好地处理流式数据。

所以，虽然 Servlet 3.1 和 WebFlux 底层都使用了 NIO，但是由于他们的编程模型和如何使用 NIO 的方式不同，WebFlux 在处理高并发、流式数据等场景时，可能会有更好的性能。但是，这并不意味着 WebFlux 在所有情况下都比 Servlet 3.1 有更好的性能，具体还需要根据应用的实际需求和场景来选择合适的技术。


### webflux和springboot虚拟线程对比
ChatGpt：
WebFlux 和 Spring Boot 使用虚拟线程（也称为纤程或轻量级线程）是两种不同的并发模型，它们各自有各自的优点和适用场景。

WebFlux：WebFlux 是 Spring 5 的一部分，它提供了一个基于反应式编程模型的非阻塞 Web 框架。WebFlux 使用少量的线程和事件驱动的方式来处理大量的并发请求，这种模型可以更有效地利用系统资源，特别是在高并发的情况下。此外，WebFlux 还支持 backpressure（背压），可以更好地处理流式数据。

Spring Boot 使用虚拟线程：Java 在其后续版本（如 Java 16）中引入了虚拟线程（Project Loom）的概念，这是一种新的并发模型，它可以创建大量的虚拟线程，每个虚拟线程都有自己的调用栈，但是它们在操作系统级别并不是真正的线程，因此创建和切换的成本更低。虚拟线程使得开发者可以使用传统的阻塞式编程模型，但是在运行时，这些阻塞操作并不会阻塞真正的物理线程，从而可以处理大量的并发请求。

WebFlux 和 Spring Boot 使用虚拟线程的主要区别在于它们的编程模型：WebFlux 使用反应式编程模型，而虚拟线程则使用更传统的阻塞式编程模型。虚拟线程的优点是编程模型更简单，更接近传统的 Java 开发方式，但是它需要更新的 Java 版本，并且目前还在实验阶段。WebFlux 的优点是它可以在任何支持 Java 8 或更高版本的环境中运行，但是它需要开发者熟悉反应式编程模型。

至于哪种模型的性能更好，这取决于具体的应用场景和负载。在某些情况下，WebFlux 可能会有更好的性能，而在其他情况下，使用虚拟线程可能会更有效。