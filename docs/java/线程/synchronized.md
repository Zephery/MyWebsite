# synchronized

*偏向锁在JDK 15后已经废弃*

## 一、什么是synchronized

关键字提供了一种简单而有效的方式来控制并发访问共享资源。但是，它也有一些限制，例如性能问题和潜在的死锁风险，在更复杂的并发场景中，可以考虑使用`java.util.concurrent`包中提供的更灵活的同步机制。

![img](https://github-images.wenzhihuai.com/images/v2-47781295251ded0e8ff32cf6a73fbfd0_1440w.webp)

## synchronized与volatile区别

| volatile                   | synchronized                     |
|------------------------|-------------------------|
| 通过禁止 CPU 缓存优化来保证变量的可见性 | 通过加锁和解锁来保证同步性和原子性       |     
| 只保证变量的可见性，还可以禁止指令重排    | 保证变量的可见性与原子性            |      
| volatile修饰变量，仅用于变量级    | synchronized锁变量或代码段，锁级  |      
| 不会造成线程阻塞               | 会造成线程阻塞                 |      
| 只是禁止了缓存优化，因此其开销相对较小    | 需要加锁、解锁等额外的操作，因此其开销相对较大 |      

## synchronized和Lock的区别

1、synchronized是java关键字，而Lock是java中的一个接口
2、synchronized会自动释放锁，而Lock必须手动释放锁
3、synchronized是不可中断的，Lock可以中断也可以不中断
4、通过Lock可以知道线程有没有拿到锁，而synchronized不能
5、synchronized能锁住方法和代码块，而Lock只能锁住代码块
6、Lock可以使用读锁提高多线程读效率
7、synchronized是非公平锁，ReentranLock可以控制是否公平锁

## 各种锁

公平锁：是指多个线程按照申请锁的顺序来获取锁。
非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
可重入锁：是指可重复可递归调用的锁，在外层使用锁之后，在内层仍然可以使用，并且不发生死锁（前提是同一个对象或者class），这样的锁就叫做可重入锁。Lock和synchronized都是可重入锁
独享锁 ：该锁每一次只能被一个线程所持有。
共享锁 ：该锁可被多个线程共有，典型的就是ReentrantReadWriteLock里的读锁，它的读锁是可以被共享的，但是它的写锁确每次只能被独占。
互斥锁 ：在访问共享资源之前对其进行加锁操作，在访问完成之后进行解锁操作。 加锁后，任何其他试图再次加锁的线程会被阻塞，直到当前进程解锁。
读写锁 ：读写锁既是互斥锁，又是共享锁，read模式是共享，write是互斥(排它锁)的
乐观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁
悲观锁：总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。
偏向锁：是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。
轻量级锁：是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。
重量级锁：是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。
自旋锁：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环 。

## 参考

1.[MarkWord和Synchronized的锁升级机制详解（JDK8）](https://zhuanlan.zhihu.com/p/676473256)
