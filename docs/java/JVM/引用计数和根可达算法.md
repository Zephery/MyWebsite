# 引用计数和根可达算法
*本文从[JVM是如何寻找垃圾的？——引用计数和根可达算法](https://zhuanlan.zhihu.com/p/669582286)转载*

### **硬件角度来看什么叫做垃圾？**

计算机的内存也叫做**[DRAM(Dynamic Random Access Memory, 动态随机访问内存)](https://zhuanlan.zhihu.com/p/539717599)**，底层是由一个电容和一个晶体管组成，电容充电表示该bit位数据为1，电容放电表示该bit位数据为0，整个内存就是无数个这样的bit位构成的。同时，内存需要在通电状态保持按周期频率的刷新，才能够维持数据的状态。

在内存中，某些内存区域（bit位）被使用过了（用来存储对象或者数据）会被打上标记表示已经被使用过了，分配新内存空间的时候就计算机硬件就不会使用这些被标记过的内存区域。通常，这些给内存区域打上标记的活儿一般由操作系统的系统调用来完成，例如C语言中的 allocate()函数调用的系统函数。

在面向对象的语言中，如果程序员新建了一个对象，那么操作系统会为其分配相应的内存区域，且该部分的内存区域会被打上标记说明已经被使用过了，这样操作系统就不会向该区域写入新的数据。

然而，如果这个标记没有被程序员释放（C语言中调用free()来释放内存区域），那么该内存区域会一直被标记成已使用，如果整个内存都被标记成为了已使用，那么当操作系统想要再分配内存的时候就会失败，这个时候只有重启电脑来解决问题了。

所以说，对于内存区域中不再使用的对象，我们需要释放掉其对应的内存区域，方便新的对象创建时有空间为其分配。而这些程序中不再被使用的对象就被称为“垃圾”，“垃圾”往往对应着内存中一块儿需要被释放的区域。

### **Java中的垃圾**

Java中"垃圾"通常指的是不再被程序使用和引用的对象，具体表现在没有被栈、JNI指针和永久代对象所引用的对象。Java作为一种面向对象的编程语言，它使用自动内存管理机制，其中垃圾收集器负责检测和回收不再被程序引用的对象，以释放它们占用的内存空间。以下是一些导致对象成为垃圾的常见情况：

- **无引用对象：** 当一个对象没有任何引用指向它时，它就变得不可达，成为垃圾，Java的垃圾收集器会识别这样的对象，并将它们回收。
- **引用循环：** 如果一组对象彼此引用形成一个循环，而这个循环与程序的其他部分没有引用相连，那么这个循环中的对象就会成为垃圾。Java的垃圾收集器通过识别引用循环并处理它们来防止内存泄漏。
- **显式置空引用：** 如果程序员显式地将一个引用置空（null），而没有其他引用指向相同的对象，那么该对象就变成了垃圾。

垃圾收集器周期性地运行，并识别和回收这些垃圾对象，释放其内存中对应的区域以确保内存能够得到有效利用，这种自动的内存管理机制就叫做垃圾回收。

## **如何寻找垃圾？**

### **引用计数（Reference Count）**

![img](https://github-images.wenzhihuai.com/images/v2-39ba8e013eb4757d88c0582e1a4d8db0_1440w.webp)

引用计数算法是一种垃圾标记，其核心思想是通过维护对象的引用计数来判断对象是否可以被回收。每个对象都有一个关联的引用计数，表示当前有多少个指针引用它。当引用计数为零时，意味着没有指针再引用该对象，因此可以安全地回收该对象的内存。

其实引用计数算法的核心思想就是，只要有对象引用我，那么就说明我是有用的，我还不需要被回收，反正，我就是没有用的对象，那么我和我的子对象都应该被回收掉。这里我们说的对象都是堆上的对象，一般是堆上的内存空间需要程序员手动回收，而栈上的内存空间则由操作系统自行回收。由于栈上的对象是操作系统自行管理和回收的，因此栈上的对象以及一些静态对象始终都是出于存活的状态，因此，堆中存活的对象至少会有一个引用（指针）指向它。

但是这样会存在着一个问题，就是对象中的引用关系形成了环状——**循环引用**，这种情况下环内所有对象的引用都是>1的，这样一来环内的所有都无法被回收从而造成“内存泄漏”。这是引用算法最主要的局限性，也是为什么JVM不采用循环计数的方法来标记垃圾的原因。

### **根可达算法（Root Search）**

由于引用计数算法无法解决“循环引用”的问题，无可避免的会造成内存泄露，因此，Java没有采用引用计数算法来寻找垃圾。而是采用了一种从GC Roots开始搜索存活对象的垃圾标记算法——根可达算法。

![img](https://github-images.wenzhihuai.com/images/v2-47d8f7958e840ee3d16c15d53cd633c8_1440w.webp)

### **哪些是GC Root？**

| GC Roots Source             | Description                                                  |
| --------------------------- | ------------------------------------------------------------ |
| 线程栈 (Thread Stacks)      | 活动线程的栈帧中的本地变量引用的对象。每个线程都有一个栈，栈中的引用对象是潜在的存活对象。 |
| 静态变量 (Static Variables) | 类的静态成员变量引用的对象。静态变量随着类的加载而初始化，它们的引用可能使对象保持存活。 |
| 常量池 (Constant Pool)      | 常量池中的引用，包括字符串常量等。这些常量在类加载时被创建，它们的引用也可能使对象保持存活。 |
| JNI 引用 (JNI References)   | 通过 JNI 在本地代码中创建的对象引用。如果 Java 代码通过 JNI 调用了本地方法，并在本地方法中创建了对象，这些对象的引用也是 GC Roots。 |
| 监控与管理 MBeans (JMX)     | 活动的监控、管理 MBeans 等通过 JMX 等管理工具注册的对象。这些对象的引用也被视为 GC Roots。 |

### **线程栈 (Thread Stacks)**

在Java中，当程序运行的时候线程会将一个个方法放到栈上来执行，并且对于方法局部的一些小的对象和变量也会被分配在栈空间上，而栈空间是由操作系统本身来控制什么时候进行释放和分配的。因此，基于这个逻辑我们可以认为对于当前线程来说，存在于栈空间上的变量都是存活的，而且栈空间一般比较小只有几MB的大小，里面存活的变量和对象都是有限的作为GC Roots来说搜索起来也是非常高效的。

### **静态变量 (Static Variables)**

在Java中静态变量一般是随着类加载的时候被创建和初始化的，和Java字节码一样，静态变量也会被加载到**元空间（Meta Space，Java 8之前叫做方法区（Method Area）或叫做永久代（Permanent Generation），Java 8之后叫做元空间）**。

元空间的对象是不会轻易被释放的，而静态变量会随着整个类被释放的时候才会被释放，因此静态变量可以作为GC Root来寻找垃圾。

### **常量池 (Constant Pool)**

常量池（Constant Pool）是Java中一种存放常量的数据结构，用于存储编译期生成的字面量和符号引用。常量池属于**元空间（Meta Space，Java 8之前叫做方法区（Method Area）或叫做永久代（Permanent Generation），Java 8之后叫做元空间）**，具体说是类加载后存放在元空间的一部分内存。

在Java程序的编译阶段，常量池会保存各种字面量和符号引用，包括字符串、类和接口的全限定名、字段和方法的名称和描述符等，这些信息在编译后会被存放在class文件的常量池中，在运行期间这些常量池依旧会存在并且Java根据常量池来映射参数。

所以，处于常量池中的变量也可以作为GC Roots来寻找垃圾

### **JNI 引用 (JNI References)**

JNI（Java Native Interface）引用是指在Java程序中通过JNI创建的与本地代码（C++代码，调用平台相关函数）相互调用的引用。JNI引用包括本地引用（Local Reference）、全局引用（Global Reference）和弱全局引用（Weak Global Reference）。

- **本地引用（Local Reference）：** 本地引用是一种短期的引用，用于限定其生命周期。当Java方法调用本地方法时，本地引用会被创建，但在本地方法返回后，这些引用将被自动释放。本地引用不能作为GC Roots。
- **全局引用（Global Reference）：** 全局引用是一种长期有效的引用，可以在整个程序的生命周期内使用。全局引用可以防止被引用对象被垃圾回收，因此它可以作为GC Roots。
- **弱全局引用（Weak Global Reference）：** 弱全局引用也是一种全局引用，但它对被引用对象的生命周期没有强制影响。如果一个对象只被弱全局引用引用，那么它在垃圾回收时可能被回收。弱全局引用不能作为GC Roots。

JNI引用之所以能作为GC Roots，是因为它们可以在本地方法（C++方法，调用平台相关函数）中持有Java对象的引用，防止这些对象在本地方法执行期间被垃圾回收。全局引用在整个程序的生命周期内有效，因此它们有可能成为根引用，即GC Roots。

### **根可达算法原理**

x知道了什么是GC Roots那么根可达算法理解起来就相对来说会简单一些。GC Roots我们可以简单理解为和Java程序的生命周期强关联、和JVM生命周期强关联或者和当前线程强关联的一些对象。这些对象至少说在发生GC这一时刻是不应该被当成垃圾回收掉的，否则会影响程序的正常使用，因此，我们标记存活对象的时候从GC Roots开始，认为被GC Roots 引用或者间接引用的对象就是存活对象。因此，根可达算法的基本原理和流程如下：

1. **初始根集合（Initial Roots）：** 根可达算法从程序的初始根集合开始，这些根是一组特殊的引用，如线程栈中的引用、静态变量、JNI（Java Native Interface）引用等。
2. **标记阶段（Mark Phase）：** 算法通过追踪根引用，递归遍历对象图，标记所有可以从根引用访问到的对象。在这个过程中，被标记的对象被认为是可达的，而未被标记的对象被认为是不可达的。
3. **标记-清除阶段（Mark-Sweep Phase）：** 在标记完成后，算法执行清除操作，即移除未被标记的对象。这些未被标记的对象被认为是不可达的，可以被垃圾回收器回收。这个阶段的目标是回收不再被程序使用的内存空间。
4. **压缩（Compaction）或整理（Compaction）：** 在某些情况下，为了优化内存布局，可能会执行进一步的操作，如将存活对象整理到一起，以减少内存碎片。这个步骤通常与标记-清除阶段结合使用。
5. **可选的再标记阶段（Optional Re-Mark Phase）：** 有些算法可能会在标记-清除后执行可选的再标记阶段，以处理在清除阶段可能发生的并发引用更新。这一步确保在垃圾回收过程中引用关系的一致性。
6. **结束（Finish）：** 垃圾回收算法完成后，内存中只留下了可达对象，而不可达的对象已被清理。程序可以继续执行。

实际上来说，如CMS和G1之类比较流行的垃圾回收器都是采用的**[“三色标记”](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484154%26idx%3D1%26sn%3D69ce4608eea3c24acf4d5d675129c240%26chksm%3Dc25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6%23rd)**算法，而非直接采用的根可达算法来对垃圾进行标记的，这里给出的流程大家参考一下就可以了。

## **总结**

本文先介绍了什么是内存垃圾以及常见的垃圾寻找算法——引用计数和根可达算法，其中，引用计数算法由于无法解决循环引用问题未被Java采用，Java中采用的是类似于“根可达算法”的**[三色标记算法](https://link.zhihu.com/?target=https%3A//mp.weixin.qq.com/s%3F__biz%3DMzkzMjI0MDY3Mw%3D%3D%26mid%3D2247484154%26idx%3D1%26sn%3D69ce4608eea3c24acf4d5d675129c240%26chksm%3Dc25f8eb4f52807a2d1470ebc831657fa9a31ef88f635687f5b39fbe6cf5302df00445b7acdc6%23rd)**。

根可达算法的核心是从GC Roots开始，标记出所有直接或者间接被GC Roots所引用的对象，这些对象被称为存活对象，剩下的对象就是垃圾。而GC Roots主要由线程、Java进程和JVM当前生命周期中存活的变量组成，主要包括：线程栈变量、静态变量、JNI引用对象和常量池对象。
