import{_ as s,c as i,d as t,o as n}from"./app-DtAVAFTf.js";const r={};function a(l,e){return n(),i("div",null,e[0]||(e[0]=[t(`<h1 id="kubernetes之request-和-limit详解" tabindex="-1"><a class="header-anchor" href="#kubernetes之request-和-limit详解"><span>Kubernetes之request 和 limit详解</span></a></h1><p>我们都知道 Kubernetes 中最小的原子调度单位是Pod，那么就意味着资源管理和资源调度相关的属性都应该Pod对象的字段，其中我们最常见的就是 Pod 的 CPU 和内存配置，而为了实现 Kubernetes 集群中资源的有效调度和充分利用，Kubernetes采用 requests 和 limits 两种限制类型来对CPU和内存资源进行容器粒度的分配。</p><div class="language-yaml line-numbers-mode" data-highlighter="shiki" data-ext="yaml" data-title="yaml" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">resources</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:  </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    limits</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:    </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        cpu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;1&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        memory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;500Mi&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">    requests</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">:    </span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        cpu</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;100m&quot;</span></span>
<span class="line"><span style="--shiki-light:#E45649;--shiki-dark:#E06C75;">        memory</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">: </span><span style="--shiki-light:#50A14F;--shiki-dark:#98C379;">&quot;1000Mi&quot;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>下面我们首先来了解一下上面这段 yaml 文件中字段的含义：requests 和 limits：</p><p><strong>requests 定义了对应的容器所需要的最小资源量。</strong><br><strong>limits 定义了对应容器最大可以消耗的资源上限。</strong><br> cpu 等于1一般等同于1CPU 核心，1个VCPU或者一个超线程，具体要看服务器的CPU。而 limits 这里设置的 100m 则叫做100毫核，100m就表示0.1个核,所以这里也可以用0.1代替。<br> memory 等于500Mi，（备注：1Mi=10241024；1M=10001000）<br> 接下来我们来初步理解 requests 和 limits 这两个资源限制类型，在 Kubernetes 对 CPU 和内存资源限额的设计，通常是指用户在提交 Pod 时，可以声明一个相对较小的 requests 值供调度器使用，而 Kubernetes 真正设置给容器 Cgroups 的，则是相对较大的 limits 值。所以一般来说，在调度的时候 requests 比较重要，在运行时 limits 比较重要。</p><p>而对应实际的业务场景来说，以 java 应用为例，requests 对应的就是JVM虚拟机所需资源的最小值，而 limits 对应的就是 JVM 虚拟机所能够使用的资源最大值。以内存资源为例一般就是指：Xms 和 Xmx，如果 requests 值设置的小于JVM虚拟机 Xms 的值，那么就会导致 Pod 内存溢出，从而导致 Pod 被杀掉，而后重新创建一个Pod。</p><p>那么如果 CPU 资源使用超过了 limits，Pod会不会被杀掉呢？答案是不会，但是被限制。如果没有设置 limits ，Pod 可以使用全部空闲的资源。另外如果设置了 limits而没有设置 requests 时，Kubernetes 默认会将 requests 等于 limits。</p><p>这里通常还会将 requests 和 limits 描述的资源分为两类：可压缩资源（compressible resources） 和不可压缩资源（incompressible resources）。这里不难看出CPU这类型资源为可压缩资源，而内存这类型资源为不可压缩资源。所以合理设置不可压缩资源的limits值就相当重要了。</p>`,8)]))}const o=s(r,[["render",a],["__file","request_limit.html.vue"]]),u=JSON.parse('{"path":"/kubernetes/request_limit.html","title":"Kubernetes之request 和 limit详解","lang":"zh-CN","frontmatter":{"description":"Kubernetes之request 和 limit详解 我们都知道 Kubernetes 中最小的原子调度单位是Pod，那么就意味着资源管理和资源调度相关的属性都应该Pod对象的字段，其中我们最常见的就是 Pod 的 CPU 和内存配置，而为了实现 Kubernetes 集群中资源的有效调度和充分利用，Kubernetes采用 requests 和 ...","head":[["meta",{"property":"og:url","content":"http://www.wenzhihuai.com/kubernetes/request_limit.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"Kubernetes之request 和 limit详解"}],["meta",{"property":"og:description","content":"Kubernetes之request 和 limit详解 我们都知道 Kubernetes 中最小的原子调度单位是Pod，那么就意味着资源管理和资源调度相关的属性都应该Pod对象的字段，其中我们最常见的就是 Pod 的 CPU 和内存配置，而为了实现 Kubernetes 集群中资源的有效调度和充分利用，Kubernetes采用 requests 和 ..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-02-16T11:46:28.000Z"}],["meta",{"property":"article:modified_time","content":"2024-02-16T11:46:28.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Kubernetes之request 和 limit详解\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-02-16T11:46:28.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zephery\\",\\"url\\":\\"https://wenzhihuai.com/article/\\"}]}"]]},"headers":[],"git":{"createdTime":1708083988000,"updatedTime":1708083988000,"contributors":[{"name":"zhihuaiwen","email":"zhihuaiwen@tencent.com","commits":1}]},"readingTime":{"minutes":2.21,"words":663},"filePathRelative":"kubernetes/request_limit.md","localizedDate":"2024年2月16日","excerpt":"\\n<p>我们都知道 Kubernetes 中最小的原子调度单位是Pod，那么就意味着资源管理和资源调度相关的属性都应该Pod对象的字段，其中我们最常见的就是 Pod 的 CPU 和内存配置，而为了实现 Kubernetes 集群中资源的有效调度和充分利用，Kubernetes采用 requests 和 limits 两种限制类型来对CPU和内存资源进行容器粒度的分配。</p>","autoDesc":true}');export{o as comp,u as data};
