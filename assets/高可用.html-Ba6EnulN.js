import{_ as e,c as n,d,o as i}from"./app-DtAVAFTf.js";const a={};function r(l,t){return i(),n("div",null,t[0]||(t[0]=[d('<h1 id="高可用" tabindex="-1"><a class="header-anchor" href="#高可用"><span>高可用</span></a></h1><p>4个9（99.99）</p><table><thead><tr><th></th><th>Sentinel</th><th>Hystrix(维护状态)</th><th>Resilience4j（Spring推荐）</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离（并发线程数限流）</td><td>线程池隔离/信号量隔离</td><td>信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于响应时间、异常比率、异常数</td><td>基于异常比率</td><td>基于异常比率、响应时间</td></tr><tr><td>实时统计实现</td><td>滑动窗口</td><td>滑动窗口</td><td>Ring Bit Buffer</td></tr><tr><td>动态规则配置</td><td>支持多种数据源</td><td>支持多种数据源</td><td>有限支持</td></tr><tr><td>扩展性</td><td>支持多种数据源</td><td>支持多种数据源</td><td>有限支持</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>有限的支持</td><td>Rate Limiter</td></tr><tr><td>流量整形</td><td>支持预热模式、匀速器模式、预热排队模式</td><td>不支持</td><td>简单的 Rate Limiter 模式</td></tr><tr><td>系统的自适应保护</td><td>支持</td><td>不支持</td><td>不支持</td></tr><tr><td>控制台</td><td>提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td><td>简单的监控查看</td><td>不提供控制台，可对接其他监控系统</td></tr></tbody></table><h2 id="流量控制" tabindex="-1"><a class="header-anchor" href="#流量控制"><span>流量控制</span></a></h2><p>流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，如下图所示：</p><figure><img src="https://github-images.wenzhihuai.com/images/sentinel-flow-overview-20240218114454907.jpg" alt="arch" tabindex="0" loading="lazy"><figcaption>arch</figcaption></figure><p>流量控制有以下几个角度:</p><ul><li>资源的调用关系，例如资源的调用链路，资源和资源之间的关系；</li><li>运行指标，例如 QPS、线程池、系统负载等；</li><li>控制的效果，例如直接限流、冷启动、排队等。</li></ul><p>Sentinel 的设计理念是让您自由选择控制的角度，并进行灵活组合，从而达到想要的效果。</p><h2 id="熔断降级" tabindex="-1"><a class="header-anchor" href="#熔断降级"><span>熔断降级</span></a></h2><h4 id="什么是熔断降级" tabindex="-1"><a class="header-anchor" href="#什么是熔断降级"><span>什么是熔断降级</span></a></h4><p>除了流量控制以外，降低调用链路中的不稳定资源也是 Sentinel 的使命之一。由于调用关系的复杂性，如果调用链路中的某个资源出现了不稳定，最终会导致请求发生堆积。这个问题和 <a href="https://github.com/Netflix/Hystrix/wiki#what-problem-does-hystrix-solve" target="_blank" rel="noopener noreferrer">Hystrix</a> 里面描述的问题是一样的。</p><figure><img src="https://github-images.wenzhihuai.com/images/62410811-cd871680-b61d-11e9-9df7-3ee41c618644.png" alt="image" tabindex="0" loading="lazy"><figcaption>image</figcaption></figure><p>Sentinel 和 Hystrix 的原则是一致的: 当调用链路中某个资源出现不稳定，例如，表现为 timeout，异常比例升高的时候，则对这个资源的调用进行限制，并让请求快速失败，避免影响到其它的资源，最终产生雪崩的效果。</p><h4 id="熔断降级设计理念" tabindex="-1"><a class="header-anchor" href="#熔断降级设计理念"><span>熔断降级设计理念</span></a></h4><p>在限制的手段上，Sentinel 和 Hystrix 采取了完全不一样的方法。</p><p>Hystrix 通过<a href="https://github.com/Netflix/Hystrix/wiki/How-it-Works#benefits-of-thread-pools" target="_blank" rel="noopener noreferrer">线程池</a>的方式，来对依赖(在我们的概念中对应资源)进行了隔离。这样做的好处是资源和资源之间做到了最彻底的隔离。缺点是除了增加了线程切换的成本，还需要预先给各个资源做线程池大小的分配。</p><p>Sentinel 对这个问题采取了两种手段:</p><ul><li>通过并发线程数进行限制</li></ul><p>和资源池隔离的方法不同，Sentinel 通过限制资源并发线程的数量，来减少不稳定资源对其它资源的影响。这样不但没有线程切换的损耗，也不需要您预先分配线程池的大小。当某个资源出现不稳定的情况下，例如响应时间变长，对资源的直接影响就是会造成线程数的逐步堆积。当线程数在特定资源上堆积到一定的数量之后，对该资源的新请求就会被拒绝。堆积的线程完成任务后才开始继续接收请求。</p><ul><li>通过响应时间对资源进行降级</li></ul><p>除了对并发线程数进行控制以外，Sentinel 还可以通过响应时间来快速降级不稳定的资源。当依赖的资源出现响应时间过长后，所有对该资源的访问都会被直接拒绝，直到过了指定的时间窗口之后才重新恢复。</p><h2 id="异地多活" tabindex="-1"><a class="header-anchor" href="#异地多活"><span>异地多活</span></a></h2><h2 id="参考" tabindex="-1"><a class="header-anchor" href="#参考"><span>参考</span></a></h2><p>1.<a href="https://sentinelguard.io/zh-cn/docs/introduction.html" target="_blank" rel="noopener noreferrer">Sentinel官网</a><br> 2.<a href="https://learn.lianglianglee.com/%E4%B8%93%E6%A0%8F/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%20Sentinel%EF%BC%88%E5%AE%8C%EF%BC%89/18%20Sentinel%20%E9%9B%86%E7%BE%A4%E9%99%90%E6%B5%81%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%88%E4%B8%8A%EF%BC%89.md" target="_blank" rel="noopener noreferrer">Sentinel 集群限流的实现（上）</a><br> 3.<a href="https://learn.lianglianglee.com/%e4%b8%93%e6%a0%8f/%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3%20Sentinel%ef%bc%88%e5%ae%8c%ef%bc%89/19%20Sentinel%20%e9%9b%86%e7%be%a4%e9%99%90%e6%b5%81%e7%9a%84%e5%ae%9e%e7%8e%b0%ef%bc%88%e4%b8%8b%ef%bc%89.md" target="_blank" rel="noopener noreferrer">Sentinel 集群限流的实现（下）</a></p>',25)]))}const o=e(a,[["render",r],["__file","高可用.html.vue"]]),p=JSON.parse('{"path":"/java/%E9%AB%98%E5%8F%AF%E7%94%A8.html","title":"高可用","lang":"zh-CN","frontmatter":{"description":"高可用 4个9（99.99） 流量控制 流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，...","head":[["meta",{"property":"og:url","content":"http://www.wenzhihuai.com/java/%E9%AB%98%E5%8F%AF%E7%94%A8.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"高可用"}],["meta",{"property":"og:description","content":"高可用 4个9（99.99） 流量控制 流量控制在网络传输中是一个常用的概念，它用于调整网络包的发送数据。然而，从系统稳定性角度考虑，在处理请求的速度上，也有非常多的讲究。任意时间到来的请求往往是随机不可控的，而系统的处理能力是有限的。我们需要根据系统的处理能力对流量进行控制。Sentinel 作为一个调配器，可以根据需要把随机的请求调整成合适的形状，..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://github-images.wenzhihuai.com/images/sentinel-flow-overview-20240218114454907.jpg"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-03-10T14:39:30.000Z"}],["meta",{"property":"article:modified_time","content":"2024-03-10T14:39:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"高可用\\",\\"image\\":[\\"https://github-images.wenzhihuai.com/images/sentinel-flow-overview-20240218114454907.jpg\\",\\"https://github-images.wenzhihuai.com/images/62410811-cd871680-b61d-11e9-9df7-3ee41c618644.png\\"],\\"dateModified\\":\\"2024-03-10T14:39:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zephery\\",\\"url\\":\\"https://wenzhihuai.com/article/\\"}]}"]]},"headers":[{"level":2,"title":"流量控制","slug":"流量控制","link":"#流量控制","children":[]},{"level":2,"title":"熔断降级","slug":"熔断降级","link":"#熔断降级","children":[]},{"level":2,"title":"异地多活","slug":"异地多活","link":"#异地多活","children":[]},{"level":2,"title":"参考","slug":"参考","link":"#参考","children":[]}],"git":{"createdTime":1710081570000,"updatedTime":1710081570000,"contributors":[{"name":"zhihuaiwen","email":"zhihuaiwen@tencent.com","commits":1}]},"readingTime":{"minutes":4.27,"words":1281},"filePathRelative":"java/高可用.md","localizedDate":"2024年3月10日","excerpt":"\\n<p>4个9（99.99）</p>\\n<table>\\n<thead>\\n<tr>\\n<th></th>\\n<th>Sentinel</th>\\n<th>Hystrix(维护状态)</th>\\n<th>Resilience4j（Spring推荐）</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td>隔离策略</td>\\n<td>信号量隔离（并发线程数限流）</td>\\n<td>线程池隔离/信号量隔离</td>\\n<td>信号量隔离</td>\\n</tr>\\n<tr>\\n<td>熔断降级策略</td>\\n<td>基于响应时间、异常比率、异常数</td>\\n<td>基于异常比率</td>\\n<td>基于异常比率、响应时间</td>\\n</tr>\\n<tr>\\n<td>实时统计实现</td>\\n<td>滑动窗口</td>\\n<td>滑动窗口</td>\\n<td>Ring Bit Buffer</td>\\n</tr>\\n<tr>\\n<td>动态规则配置</td>\\n<td>支持多种数据源</td>\\n<td>支持多种数据源</td>\\n<td>有限支持</td>\\n</tr>\\n<tr>\\n<td>扩展性</td>\\n<td>支持多种数据源</td>\\n<td>支持多种数据源</td>\\n<td>有限支持</td>\\n</tr>\\n<tr>\\n<td>限流</td>\\n<td>基于 QPS，支持基于调用关系的限流</td>\\n<td>有限的支持</td>\\n<td>Rate Limiter</td>\\n</tr>\\n<tr>\\n<td>流量整形</td>\\n<td>支持预热模式、匀速器模式、预热排队模式</td>\\n<td>不支持</td>\\n<td>简单的 Rate Limiter 模式</td>\\n</tr>\\n<tr>\\n<td>系统的自适应保护</td>\\n<td>支持</td>\\n<td>不支持</td>\\n<td>不支持</td>\\n</tr>\\n<tr>\\n<td>控制台</td>\\n<td>提供开箱即用的控制台，可配置规则、查看秒级监控、机器发现等</td>\\n<td>简单的监控查看</td>\\n<td>不提供控制台，可对接其他监控系统</td>\\n</tr>\\n</tbody>\\n</table>","autoDesc":true}');export{o as comp,p as data};
