import{_ as t,c as l,d as a,o as r}from"./app-DtAVAFTf.js";const o={};function p(n,e){return r(),l("div",null,e[0]||(e[0]=[a('<h1 id="webflux" tabindex="-1"><a class="header-anchor" href="#webflux"><span>Webflux</span></a></h1><h3 id="_1-servlet-3-1就已经支持异步非阻塞-为什么要用webflux" tabindex="-1"><a class="header-anchor" href="#_1-servlet-3-1就已经支持异步非阻塞-为什么要用webflux"><span>1.Servlet 3.1就已经支持异步非阻塞，为什么要用webflux?</span></a></h3><p>ChatGpt:<br> Servlet 3.1 和 WebFlux 虽然底层都使用了 Java 的 NIO（非阻塞 IO），但是他们的编程模型和如何使用 NIO 是不同的，这也是导致他们性能差异的原因。</p><p>Servlet 3.1：虽然 Servlet 3.1 支持非阻塞 IO，但是它的 API 设计仍然是基于传统的阻塞模型，这意味着每个请求通常会在一个单独的线程中处理，直到请求处理完成并返回响应。这种模型在并发请求数量较少的情况下工作得很好，但是在高并发的情况下，可能会因为线程数量过多而导致资源消耗过大，性能下降。</p><p>WebFlux：WebFlux 是基于反应式编程模型的，它使用少量的线程（通常与 CPU 核心数相同）和事件驱动的方式来处理大量的并发请求。这种模型可以更有效地利用系统资源，特别是在高并发的情况下。此外，WebFlux 还支持 backpressure（背压），可以更好地处理流式数据。</p><p>所以，虽然 Servlet 3.1 和 WebFlux 底层都使用了 NIO，但是由于他们的编程模型和如何使用 NIO 的方式不同，WebFlux 在处理高并发、流式数据等场景时，可能会有更好的性能。但是，这并不意味着 WebFlux 在所有情况下都比 Servlet 3.1 有更好的性能，具体还需要根据应用的实际需求和场景来选择合适的技术。</p><h3 id="webflux和springboot虚拟线程对比" tabindex="-1"><a class="header-anchor" href="#webflux和springboot虚拟线程对比"><span>webflux和springboot虚拟线程对比</span></a></h3><p>ChatGpt：<br> WebFlux 和 Spring Boot 使用虚拟线程（也称为纤程或轻量级线程）是两种不同的并发模型，它们各自有各自的优点和适用场景。</p><p>WebFlux：WebFlux 是 Spring 5 的一部分，它提供了一个基于反应式编程模型的非阻塞 Web 框架。WebFlux 使用少量的线程和事件驱动的方式来处理大量的并发请求，这种模型可以更有效地利用系统资源，特别是在高并发的情况下。此外，WebFlux 还支持 backpressure（背压），可以更好地处理流式数据。</p><p>Spring Boot 使用虚拟线程：Java 在其后续版本（如 Java 16）中引入了虚拟线程（Project Loom）的概念，这是一种新的并发模型，它可以创建大量的虚拟线程，每个虚拟线程都有自己的调用栈，但是它们在操作系统级别并不是真正的线程，因此创建和切换的成本更低。虚拟线程使得开发者可以使用传统的阻塞式编程模型，但是在运行时，这些阻塞操作并不会阻塞真正的物理线程，从而可以处理大量的并发请求。</p><p>WebFlux 和 Spring Boot 使用虚拟线程的主要区别在于它们的编程模型：WebFlux 使用反应式编程模型，而虚拟线程则使用更传统的阻塞式编程模型。虚拟线程的优点是编程模型更简单，更接近传统的 Java 开发方式，但是它需要更新的 Java 版本，并且目前还在实验阶段。WebFlux 的优点是它可以在任何支持 Java 8 或更高版本的环境中运行，但是它需要开发者熟悉反应式编程模型。</p><p>至于哪种模型的性能更好，这取决于具体的应用场景和负载。在某些情况下，WebFlux 可能会有更好的性能，而在其他情况下，使用虚拟线程可能会更有效。</p>',12)]))}const u=t(o,[["render",p],["__file","webflux.html.vue"]]),b=JSON.parse('{"path":"/java/SpringBoot/webflux.html","title":"Webflux","lang":"zh-CN","frontmatter":{"description":"Webflux 1.Servlet 3.1就已经支持异步非阻塞，为什么要用webflux? ChatGpt: Servlet 3.1 和 WebFlux 虽然底层都使用了 Java 的 NIO（非阻塞 IO），但是他们的编程模型和如何使用 NIO 是不同的，这也是导致他们性能差异的原因。 Servlet 3.1：虽然 Servlet 3.1 支持非阻塞...","head":[["meta",{"property":"og:url","content":"http://www.wenzhihuai.com/java/SpringBoot/webflux.html"}],["meta",{"property":"og:site_name","content":"个人博客"}],["meta",{"property":"og:title","content":"Webflux"}],["meta",{"property":"og:description","content":"Webflux 1.Servlet 3.1就已经支持异步非阻塞，为什么要用webflux? ChatGpt: Servlet 3.1 和 WebFlux 虽然底层都使用了 Java 的 NIO（非阻塞 IO），但是他们的编程模型和如何使用 NIO 是不同的，这也是导致他们性能差异的原因。 Servlet 3.1：虽然 Servlet 3.1 支持非阻塞..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-27T09:51:43.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-27T09:51:43.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Webflux\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-01-27T09:51:43.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Zephery\\",\\"url\\":\\"https://wenzhihuai.com/article/\\"}]}"]]},"headers":[{"level":3,"title":"1.Servlet 3.1就已经支持异步非阻塞，为什么要用webflux?","slug":"_1-servlet-3-1就已经支持异步非阻塞-为什么要用webflux","link":"#_1-servlet-3-1就已经支持异步非阻塞-为什么要用webflux","children":[]},{"level":3,"title":"webflux和springboot虚拟线程对比","slug":"webflux和springboot虚拟线程对比","link":"#webflux和springboot虚拟线程对比","children":[]}],"git":{"createdTime":1706349103000,"updatedTime":1706349103000,"contributors":[{"name":"zhihuaiwen","email":"zhihuaiwen@tencent.com","commits":1}]},"readingTime":{"minutes":3.07,"words":921},"filePathRelative":"java/SpringBoot/webflux.md","localizedDate":"2024年1月27日","excerpt":"\\n<h3>1.Servlet 3.1就已经支持异步非阻塞，为什么要用webflux?</h3>\\n<p>ChatGpt:<br>\\nServlet 3.1 和 WebFlux 虽然底层都使用了 Java 的 NIO（非阻塞 IO），但是他们的编程模型和如何使用 NIO 是不同的，这也是导致他们性能差异的原因。</p>","autoDesc":true}');export{u as comp,b as data};
